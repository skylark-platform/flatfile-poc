import Backoff from 'backo2';
import { ListenerFn } from 'eventemitter3';

interface Observer<T> {
    next?: (value: T) => void;
    error?: (error: Error) => void;
    complete?: () => void;
}
interface Observable<T> {
    subscribe(observer: Observer<T>): {
        unsubscribe: () => void;
    };
}
interface OperationOptions {
    query: string;
    variables?: Object;
    operationName?: string;
    [key: string]: any;
}
declare type OperationsHandler = (error?: Error, data?: unknown) => any;
declare type ConnectionParams = {
    [paramName: string]: unknown;
};
declare type ConnectionParamsOptions = ConnectionParams | Function | Promise<ConnectionParams>;
interface ClientOptions {
    connectionCallback?: (error?: Error[], result?: unknown) => void;
    connectionParams?: ConnectionParamsOptions;
    minTimeout?: number;
    timeout?: number;
    reconnect?: boolean;
    reconnectionAttempts?: number;
    lazy?: boolean;
    inactivityTimeout?: number;
}
declare type MessageType = 'start' | 'stop' | 'connection_init' | 'connection_terminate' | 'connection_error';
declare class SubscriptionClient {
    private wsImpl;
    private readonly connectionCallback;
    private readonly url;
    private readonly operations;
    private nextOperationId;
    private readonly wsMinTimeout;
    private readonly wsTimeout;
    private unsentMessagesQueue;
    private readonly reconnect;
    private reconnecting;
    private readonly reconnectionAttempts;
    private readonly lazy;
    private readonly inactivityTimeout;
    private closedByUser;
    private backoff;
    private eventEmitter;
    private client;
    private maxConnectTimeGenerator;
    private readonly connectionParams;
    private checkConnectionIntervalId;
    private maxConnectTimeoutId;
    private tryReconnectTimeoutId;
    private inactivityTimeoutId;
    private wasKeepAliveReceived;
    constructor(url: string, options?: ClientOptions);
    get status(): number;
    close(isForced?: boolean, closedByUser?: boolean): void;
    request(request: OperationOptions): {
        [x: symbol]: () => any;
        subscribe(observerOrNext: any, onError?: any, onComplete?: any): {
            unsubscribe: () => void;
        };
    };
    on(eventName: string, callback: ListenerFn, context: unknown): () => void;
    onConnected(callback: ListenerFn, context: unknown): () => void;
    onConnecting(callback: ListenerFn, context: unknown): () => void;
    onDisconnected(callback: ListenerFn, context: unknown): () => void;
    onReconnected(callback: ListenerFn, context: unknown): () => void;
    onReconnecting(callback: ListenerFn, context: unknown): () => void;
    onError(callback: ListenerFn, context: unknown): () => void;
    unsubscribeAll(): void;
    getConnectionParams(connectionParams: Function | {
        [key: string]: any;
    }): () => Promise<unknown>;
    executeOperation(options: OperationOptions, handler: OperationsHandler): string;
    getObserver(observerOrNext?: any, error?: any, complete?: any): any;
    createMaxConnectTimeGenerator(): Backoff;
    clearCheckConnectionInterval(): void;
    clearMaxConnectTimeout(): void;
    clearTryReconnectTimeout(): void;
    clearInactivityTimeout(): void;
    setInactivityTimeout(): void;
    checkOperationOptions(options: OperationOptions, handler: OperationsHandler): void;
    buildMessage(id: string, type: MessageType, payload: any): {
        id: string;
        type: MessageType;
        payload: any;
    };
    formatErrors(errors: any): any;
    sendMessage(id: string | undefined, type: MessageType, payload: any): void;
    sendMessageRaw(message: any): void;
    generateOperationId(): string;
    tryReconnect(): void;
    flushUnsentMessagesQueue(): void;
    checkConnection(): void;
    checkMaxConnectTimeout(): void;
    connect(): void;
    processReceivedMessage(message: any): void;
    unsubscribe(opId: string): void;
}

export { ClientOptions, ConnectionParams, ConnectionParamsOptions, Observable, Observer, OperationOptions, OperationsHandler, SubscriptionClient };
