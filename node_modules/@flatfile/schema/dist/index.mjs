// src/convert.ts
import {
  filter,
  fromPairs,
  isTruthy,
  map,
  mapValues,
  pick,
  pipe,
  values
} from "remeda";
var compileEnum = (inputField) => {
  if (inputField.type !== "enum") {
    return inputField;
  }
  return {
    type: "string",
    label: inputField.label,
    ...inputField.required ? { required: inputField.required } : {},
    enum: map(Object.keys(inputField.labelEnum), (key) => key),
    enumLabel: map(Object.values(inputField.labelEnum), (key) => key)
  };
};
var SchemaILToJsonSchema = (ddl) => {
  const fields = pipe(ddl.fields, mapValues((value, field) => ({
    field,
    ...compileEnum(value)
  })), values);
  const required = pipe(fields, filter((f) => isTruthy(f.required)), map((f) => f.field));
  const unique = pipe(fields, filter((f) => isTruthy(f.unique)), map((f) => f.field));
  const pks = pipe(fields, filter((f) => isTruthy(f.primary)), map((f) => f.field));
  const properties = pipe(fields, map((f) => tuple(f.field, {
    ...pick(f, [
      "type",
      "label",
      "field",
      "enum",
      "enumLabel",
      "description"
    ]),
    visibility: f.stageVisibility,
    ...f.type === "schema_ref" ? { $schemaId: f.sheetName } : {}
  })), (v) => fromPairs(v));
  return {
    properties,
    type: "object",
    required,
    unique,
    primary: pks[0],
    allowCustomFields: ddl.allowCustomFields
  };
};
var compileToJsonSchema = SchemaILToJsonSchema;
function tuple(a, b) {
  return [a, b];
}
export {
  SchemaILToJsonSchema,
  compileEnum,
  compileToJsonSchema
};
