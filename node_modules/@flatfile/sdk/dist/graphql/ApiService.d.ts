import { ClientError, GraphQLClient } from 'graphql-request';
import { GraphQLError } from 'graphql-request/dist/types';
import { SubscriptionClient } from 'graphql-subscriptions-client';
import { IImportMeta, ImportSession } from '../importer/ImportSession';
import { ERecordStatus, TPrimitive } from '../service/FlatfileRecord';
import { InitializeEmptyBatchResponse } from './mutations/INITIALIZE_EMPTY_BATCH';
import { GetFinalDatabaseViewResponse } from './queries/GET_FINAL_DATABASE_VIEW';
import { IBatch } from './subscriptions/BATCH_STATUS_UPDATED';
export declare class ApiService {
    token: string;
    apiUrl: string;
    client: GraphQLClient;
    pubsub: SubscriptionClient;
    constructor(token: string, apiUrl: string);
    /**
     * Initialize a new batch or obtain the current batch
     *
     * @private
     */
    initEmptyBatch(synced?: boolean): Promise<InitializeEmptyBatchResponse['initializeEmptyBatch']>;
    /**
     * Initialize an empty batch or obtain the current one, returns normalized
     * payload.
     */
    init(synced?: boolean): Promise<IImportMeta>;
    /**
     * Get the current main workbook id for any batch
     *
     * @param batchId
     * @private
     */
    getWorkbookId(batchId: string): Promise<string>;
    /**
     * @deprecated this should not be used ever
     * @param batchId
     * @param skip
     * @param sample
     * @param limit
     */
    getAllRecords(batchId: string, skip?: number, sample?: boolean, limit?: number): Promise<GetFinalDatabaseViewResponse['getFinalDatabaseView']>;
    /**
     * Return a list of FlatfileRecords based on status
     *
     * @todo clean up validation status vs stage and support both
     *
     * @param session
     * @param status
     * @param skip
     * @param limit
     */
    getRecordsByStatus(session: ImportSession, status: ERecordStatus, skip?: number, limit?: number): Promise<GetFinalDatabaseViewResponse['getFinalDatabaseView']>;
    /**
     * Bulk update record statuses by ids
     *
     * @param session
     * @param recordIds
     * @param status
     */
    updateRecordStatus(session: ImportSession, recordIds: number[], status: ERecordStatus): Promise<{
        id: string;
    } | void>;
    /**
     * Update the value of one or more session environment keys
     *
     * @param session
     * @param env
     */
    updateSessionEnv(session: ImportSession, env: Record<string, TPrimitive>): Promise<{
        success: boolean;
    }>;
    /**
     * Get batch
     *
     * @param batchId
     */
    getBatch(batchId: string): Promise<{
        id: string;
        status: string;
    }>;
    /**
     * get batch and check status for subscription fail fallback
     *
     * @param batchId
     */
    fallbackGetBatchSubscription: (batchId: string) => Promise<{
        result: IBatch;
        stopPoll: boolean;
    } | null>;
    /**
     * Start a websocket subscription for a specific batchID
     *
     * @param batchId
     * @param observe
     */
    subscribeBatchStatusUpdated(batchId: string, observe: (batch: IBatch) => void): Promise<void>;
    handleRawError(error?: ClientError | Error | string): void;
    handleGraphQLErrors(errors?: GraphQLError[], message?: string): void;
    handleResponse<T, K extends keyof T>(queryName: K, query: Promise<T>): Promise<T[K]>;
}
