import { ApiService } from '../graphql/ApiService';
import { ImportSession } from '../importer/ImportSession';
import { PartialRejection } from '../service/PartialRejection';
import { RecordsChunk } from '../service/RecordsChunk';
import { TypedEventManager } from './TypedEventManager';
export declare class RecordChunkIterator extends TypedEventManager<IIteratorEvents> {
    private session;
    private options;
    /**
     * Reference to API service for
     * @private
     */
    api: ApiService;
    /**
     * Tracks the IDs of the records that have been accepted from all chunks
     */
    acceptedIds: number[];
    /**
     * Tracks the IDs of the records that have been rejected in all chunks
     */
    rejectedIds: number[];
    /**
     * This is a placeholder for the external function used for processing the chunk
     * @private
     */
    private readonly callback;
    /**
     * Holds the timeout tracking the time spent while running the callback
     */
    private timerId?;
    /**
     * Its true if the data processing was stopped
     */
    private isProcessingStopped;
    constructor(session: ImportSession, callback: IteratorCallback, options: {
        chunkSize: number;
        chunkTimeout: number;
    });
    /**
     * Is run after each chunk is processed and receives the response from each callback
     *
     * @param prevChunk
     * @param err
     */
    afterEach(prevChunk: RecordsChunk, err?: PartialRejection | Error): Promise<void>;
    /**
     * Used to load the first payload for the first chunk
     */
    beforeFirst(): Promise<RecordsChunk>;
    /**
     * Gets run before each chunk except the first one.
     *
     * @param chunk
     */
    beforeOthers(chunk: RecordsChunk): Promise<RecordsChunk | null>;
    /**
     * Process the next chunk in the series or complete the process.
     *
     * @param chunk
     * @param err
     */
    next(chunk: RecordsChunk, err?: PartialRejection | Error): Promise<void>;
    /**
     * Run through this chunk iterator once using the available rules.
     */
    process(): Promise<void>;
    /**
     * After all the chunks have finished iterating. This hook is run to wrap things up
     */
    afterAll(): Promise<void>;
    /**
     * Runs the iterator callback function and adds a timeout tracking the time spent running it.
     * If the iterator callback takes longer than expected, an error is emitted.
     */
    private runCallback;
    /**
     * Handles the errors that produce an stop in the records processing.
     * Only emits a 'complete' event the first time it is called (or when 'isProcessingStopped' flag is false).
     */
    private stopDataProcessing;
}
export declare type IteratorCallback = (chunk: RecordsChunk, next: (res?: PartialRejection | Error) => void) => Promise<void> | void;
export interface IIteratorEvents {
    complete?: Error;
    error: {
        error: Error;
    };
}
