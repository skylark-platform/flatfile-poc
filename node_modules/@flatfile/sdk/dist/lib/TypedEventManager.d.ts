import { IEvents } from '../types';
export declare const eventManager: import("eventemitter3")<string | symbol, any>;
export declare class TypedEventManager<T> {
    private em;
    private proxies;
    constructor();
    emit<K extends Diff<keyof T, AllowedNames<IEvents, undefined>>, Attr extends T[K]>(event: K, payload?: Attr | undefined): this;
    hasListener<K extends keyof T>(event: K): boolean;
    listen<K extends keyof T>(event: K, cb: (e: T[K]) => void): () => this;
    on<K extends keyof T>(event: K, cb: (e: T[K]) => void | Promise<void>): this;
    off<K extends keyof T>(event: K, cb: (e: T[K]) => void): this;
    cleanup(): this;
    proxyTo(em1: TypedEventManager<any>): this;
    /**
     * Forwards all the events of a given type to another event emitter
     *
     * @param eventName The event type to be forwarded
     * @param em The event emitter the events will be forwarded to
     */
    bubble<K extends keyof T>(eventName: K, em: TypedEventManager<Record<K, T[K]>>): void;
}
declare type FilterFlags<Base, Condition> = {
    [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
};
declare type AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];
declare type Diff<T, U> = T extends U ? never : T;
export {};
