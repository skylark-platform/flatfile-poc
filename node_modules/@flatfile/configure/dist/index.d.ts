import { SchemaILModel, IJsonSchema, BaseFieldTypes, SchemaILField } from '@flatfile/schema';
import * as _flatfile_hooks from '@flatfile/hooks';
import { FlatfileRecord, FlatfileRecords, FlatfileSession, TPrimitive } from '@flatfile/hooks';

declare class UniqueAndRequiredPlugin {
    run(fields: FieldConfig, records: FlatfileRecord<any>[]): void;
}
declare type RecordsComputeType = (records: FlatfileRecords<any>, session?: FlatfileSession, logger?: any) => Promise<void>;
declare type RecordCompute = {
    dependsOn?: string[];
    uses?: string[];
    modifies?: string[];
    (record: FlatfileRecord<any>, session: FlatfileSession, logger?: any): void;
};
interface SheetOptions<FC> {
    allowCustomFields: boolean;
    readOnly: boolean;
    recordCompute: RecordCompute;
    batchRecordsCompute: RecordsComputeType;
    previewFieldKey?: string;
}
declare class Sheet<FC extends FieldConfig> {
    name: string;
    fields: FieldConfig;
    passedOptions?: Partial<SheetOptions<FC>> | undefined;
    options: SheetOptions<FC>;
    private contributedRecordFuncs;
    idFromAPI: string | undefined;
    constructor(name: string, fields: FieldConfig, passedOptions?: Partial<SheetOptions<FC>> | undefined);
    runProcess(records: FlatfileRecords<any>, session: FlatfileSession, logger: any): Promise<void>;
    toSchemaIL(namespace: string, slug: string): SchemaILModel;
    toJSONSchema(namespace: string, slug: string): IJsonSchema;
}
declare type FieldConfig = Record<string, Field<any, any>>;

declare type TRecordStageLevel = 'cast' | 'required' | 'compute' | 'validate' | 'apply' | 'other';
declare type TRecordLevel = 'error' | 'warn' | 'info';
declare class Value<T> {
    readonly value: T;
    readonly meta: Record<any, any>;
    constructor(value: T, meta: Record<any, any>);
}
declare type Dirty<T> = string | null | T;
declare type Nullable<T> = null | T;
declare type Waitable<T> = T;
declare type Writable<T> = Waitable<T | Value<T>>;
declare class Message {
    readonly message: string;
    readonly level: TRecordLevel;
    readonly stage: TRecordStageLevel;
    constructor(message: string, level: TRecordLevel, stage: TRecordStageLevel);
}
interface IFieldHooks<T> {
    cast: (value: Dirty<T>) => Nullable<T>;
    default: Nullable<T>;
    compute: (value: T) => T;
    validate: (value: T) => void | Message[];
}
declare const FieldHookDefaults: <T>() => IFieldHooks<T>;
interface GenericFieldOptions {
    description: string;
    type: BaseFieldTypes;
    label: string;
    primary: boolean;
    required: boolean;
    unique: boolean;
    annotations?: {
        default?: boolean;
        defaultMessage?: string;
        compute?: boolean;
        computeMessage: string;
    };
    stageVisibility?: {
        mapping?: boolean;
        review?: boolean;
        export?: boolean;
    };
}
declare type BaseFieldOptions<T> = Partial<SchemaILField> & Partial<IFieldHooks<T>>;
declare type FullBaseFieldOptions<T, O> = SchemaILField & IFieldHooks<T> & O;
declare class Field<T, O extends Record<string, any>> {
    options: FullBaseFieldOptions<T, O>;
    constructor(options?: FullBaseFieldOptions<T, O>);
    addCustomOptionsToField(cb: (options: FullBaseFieldOptions<T, O>) => void): void;
    extraFieldsToAdd: Record<string, Field<any, any>>;
    toCastDefault(rawValue: any): [Nullable<T>, Message[]];
    computeFromValue(reallyActuallyCast: T, rawValue: any): [Nullable<T>, Message[]];
    computeToValue(rawValue: any): [Nullable<T>, Message[]];
    validate(val: T): void | Message[];
    toSchemaILField(fieldName: string): SchemaILField;
    contributeToSchemaILFBase(): void;
    setProp(prop: Partial<FullBaseFieldOptions<T, O>>): this;
}
declare type PartialBaseFieldsAndOptions<T, O> = Partial<FullBaseFieldOptions<T, O>>;
declare type FieldOverload<T, O extends Record<string, any>> = {
    (): Field<T, O>;
    (label?: string): Field<T, O>;
    (options?: PartialBaseFieldsAndOptions<T, O>): Field<T, O>;
};
declare const TextField: FieldOverload<string, {}>;
declare const BooleanField: FieldOverload<boolean, {
    superBoolean?: boolean | undefined;
}>;
declare const NumberField: FieldOverload<number, {}>;
declare const DateField: FieldOverload<Date, {}>;
declare type LabelOptions = string | {
    label: string;
};
declare const OptionField: FieldOverload<string, {
    options: Record<string, LabelOptions>;
}>;
declare const LinkedField: FieldOverload<string, {
    sheet: Sheet<FieldConfig>;
}>;

interface PortalOption {
    name: string;
    sheet: string;
    archived?: boolean;
    helpContent?: string;
}
declare class Portal {
    readonly options: PortalOption;
    privateKeyString: string | undefined;
    id: string | undefined;
    constructor(options: PortalOption);
    setId(id: string): void;
    setPrivateKeyString(privateKeyString: string): void;
}

declare class Workbook {
    readonly options: IWorkbookOptions;
    constructor(options: IWorkbookOptions);
    processRecords(records: FlatfileRecords<any>, payload: IHookPayload, logger?: any): Promise<void>;
    handleLegacyDataHook(payload: IHookPayload): Promise<_flatfile_hooks.IRawRecordWithInfo<_flatfile_hooks.TRecordData<_flatfile_hooks.TPrimitive>>[]>;
    runHookOnLambda: ({ recordBatch, session, logger, eventType, }: {
        recordBatch: FlatfileRecords<any>;
        session: FlatfileSession;
        logger: any;
        eventType?: string | undefined;
    }) => Promise<_flatfile_hooks.IRawRecordWithInfo<any>[]>;
}
interface IHookPayload {
    workspaceId: string;
    workbookId: string;
    schemaId: number;
    schemaSlug: string;
    uploads: string[];
    rows: any;
    endUser?: any;
    env?: Record<string, string | boolean | number>;
    envSignature?: string;
}
interface IWorkbookOptions {
    namespace: string;
    name: string;
    sheets: Record<string, Sheet<any>>;
    ref?: string;
    options?: {};
    portals?: Portal[];
}

declare type Format = 'full' | 'iso-2' | 'iso-3';
declare const CountryCast: (toFormat: Format) => (raw: string | null | undefined) => string | null;
declare const StateCast: (toFormat: 'full' | 'two-letter') => (raw: string | null | undefined) => string | null;
declare const StateAndTerritoryCast: (toFormat: 'full' | 'two-letter') => (raw: string | null | undefined) => string | null;

declare const SubstitutionCast: (matchingLists: TPrimitive[][], outputColNum: number, errorFunc: (wrongVal: string) => string) => (raw: string | null | undefined) => string | null;
declare const StringSubstitutionCast: (matchingLists: string[][], outputColNum: number, errorFunc: (wrongVal: string) => string) => (raw: string | null | undefined) => string | null;

export { BaseFieldOptions, BooleanField, CountryCast, DateField, Dirty, Field, FieldConfig, FieldHookDefaults, FullBaseFieldOptions, GenericFieldOptions, IFieldHooks, IHookPayload, LinkedField, Message, Nullable, NumberField, OptionField, Portal, RecordCompute, RecordsComputeType, Sheet, SheetOptions, StateAndTerritoryCast, StateCast, StringSubstitutionCast, SubstitutionCast, TRecordStageLevel, TextField, UniqueAndRequiredPlugin, Waitable, Workbook, Writable };
