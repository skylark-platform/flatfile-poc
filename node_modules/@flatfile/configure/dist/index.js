"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BooleanField: () => BooleanField,
  CountryCast: () => CountryCast,
  DateField: () => DateField,
  Field: () => Field,
  FieldHookDefaults: () => FieldHookDefaults,
  LinkedField: () => LinkedField,
  Message: () => Message,
  NumberField: () => NumberField,
  OptionField: () => OptionField,
  Portal: () => Portal,
  Sheet: () => Sheet,
  StateAndTerritoryCast: () => StateAndTerritoryCast,
  StateCast: () => StateCast,
  StringSubstitutionCast: () => StringSubstitutionCast,
  SubstitutionCast: () => SubstitutionCast,
  TextField: () => TextField,
  UniqueAndRequiredPlugin: () => UniqueAndRequiredPlugin,
  Workbook: () => Workbook
});
module.exports = __toCommonJS(src_exports);

// src/ddl/Field.ts
var import_remeda = require("remeda");

// src/utils/isFullyPresent.ts
var isFullyPresent = (val) => {
  return val !== null && val !== void 0;
};

// src/ddl/Field.ts
var _ = __toESM(require("lodash"));

// src/stdlib/CastFunctions.ts
var import_date_fns = require("date-fns");
var num;
var NumberCast = (raw) => {
  if (typeof raw === "undefined") {
    return null;
  } else if (raw === null) {
    return null;
  } else {
    if (typeof raw === "number") {
      num = raw;
    } else if (typeof raw === "string") {
      if (raw === "") {
        return null;
      }
      const strippedStr = raw.replace(",", "");
      num = Number(strippedStr);
    }
    if (isFinite(num)) {
      return num;
    } else {
      throw new Error(`'${raw}' parsed to '${num}' which is non-finite`);
    }
  }
};
var TRUTHY_VALUES = ["1", "yes", "true", "on", "t", "y"];
var FALSY_VALUES = ["-1", "0", "no", "false", "off", "f", "n"];
var BooleanCast = (raw) => {
  if (typeof raw === "undefined") {
    return null;
  } else if (raw === null) {
    return null;
  } else {
    if (typeof raw === "boolean") {
      return raw;
    } else if (typeof raw === "string") {
      if (raw === "") {
        return null;
      }
      const normString = raw.toLowerCase();
      if (TRUTHY_VALUES.includes(normString)) {
        return true;
      }
      if (FALSY_VALUES.includes(normString)) {
        return false;
      }
      throw new Error(`'${raw}' can't be converted to boolean`);
    }
    return null;
  }
};
var StringCast = (raw) => {
  if (typeof raw === "undefined") {
    return null;
  } else if (raw === null) {
    return null;
  } else {
    if (typeof raw === "string") {
      if (raw === "") {
        return null;
      }
    }
    return raw;
  }
};
var DateCast = (raw) => {
  if (typeof raw === "undefined") {
    return null;
  } else if (raw === null) {
    return null;
  } else if (raw instanceof Date) {
    return raw;
  } else if (typeof raw === "number") {
    const numParsed = (0, import_date_fns.toDate)(raw);
    if ((0, import_date_fns.isValid)(numParsed)) {
      return numParsed;
    } else {
      throw new Error(`${raw} parsed to '${numParsed}' which is invalid`);
    }
  } else if (typeof raw === "string") {
    if (raw === "") {
      return null;
    }
    const parsedDate = new Date(raw);
    if ((0, import_date_fns.isValid)(parsedDate)) {
      return parsedDate;
    } else {
      throw new Error(`'${raw}' parsed to '${parsedDate}' which is invalid`);
    }
  }
  return null;
};
var StringCastCompose = (otherFunc) => {
  const innerCast = (raw) => {
    const stringVal = StringCast(raw);
    if (stringVal === null) {
      return null;
    }
    return otherFunc(stringVal);
  };
  return innerCast;
};

// src/ddl/Field.ts
var Message = class {
  constructor(message, level = "info", stage) {
    this.message = message;
    this.level = level;
    this.stage = stage;
  }
};
var FieldHookDefaults = () => ({
  cast: (value) => {
    if (value != null) {
      return value;
    }
    return null;
  },
  default: null,
  compute: (value) => value,
  validate: () => []
});
var GenericDefaults = {
  description: "",
  label: "",
  type: "string",
  primary: false,
  required: false,
  unique: false,
  stageVisibility: {
    mapping: true,
    review: true,
    export: true
  },
  annotations: {
    default: false,
    defaultMessage: "This field was automatically given a default value of",
    compute: false,
    computeMessage: "This value was automatically reformatted - original data:"
  }
};
var Field = class {
  constructor(options = {}) {
    this.options = options;
    this.extraFieldsToAdd = {};
  }
  addCustomOptionsToField(cb) {
    cb(this.options);
  }
  toCastDefault(rawValue) {
    const extraMessages = [];
    const possiblyCast = this.options.cast(rawValue);
    if (typeof possiblyCast === "undefined") {
      throw new Error(`casting ${rawValue} returned undefined.  This is an error, fix 'cast' function`);
    }
    let actuallyCast;
    if (!isFullyPresent(possiblyCast) && isFullyPresent(this.options.default)) {
      if (this.options.annotations.default) {
        extraMessages.push(new Message(`${this.options.annotations.defaultMessage} '${this.options.default}'`, "info", "other"));
      }
      actuallyCast = this.options.default;
    } else {
      actuallyCast = possiblyCast;
    }
    return [actuallyCast, extraMessages];
  }
  computeFromValue(reallyActuallyCast, rawValue) {
    const compMessages = [];
    const computed = this.options.compute(reallyActuallyCast);
    if (typeof computed === "undefined") {
      throw new Error(`Calling compute of ${rawValue} with typed value of ${reallyActuallyCast} returned undefined.  This is an error, fix 'compute' function`);
    }
    if (reallyActuallyCast !== computed && this.options.annotations.compute) {
      compMessages.push(new Message(`${this.options.annotations.computeMessage} '${reallyActuallyCast}'`, "info", "other"));
    }
    return [computed, compMessages];
  }
  computeToValue(rawValue) {
    try {
      const [actuallyCast, extraMessages] = this.toCastDefault(rawValue);
      if (isFullyPresent(actuallyCast)) {
        try {
          const reallyActuallyCast = actuallyCast;
          const [computed, compMessages] = this.computeFromValue(reallyActuallyCast, rawValue);
          return [computed, _.concat(extraMessages, compMessages)];
        } catch (e) {
          return [
            rawValue,
            _.concat(extraMessages, new Message(e.toString(), "error", "compute"))
          ];
        }
      } else {
        if (this.options.required) {
          return [
            null,
            _.concat(extraMessages, new Message("missing value", "error", "required"))
          ];
        }
        return [null, []];
      }
    } catch (e) {
      return [rawValue, [new Message(e.toString(), "error", "cast")]];
    }
  }
  validate(val) {
    try {
      return this.options.validate(val);
    } catch (e) {
      return [new Message(e.toString(), "error", "validate")];
    }
  }
  toSchemaILField(fieldName) {
    return {
      field: fieldName,
      label: this.options.label || fieldName,
      ...(0, import_remeda.pick)(this.options, [
        "type",
        "description",
        "required",
        "primary",
        "unique",
        "labelEnum",
        "sheetName",
        "stageVisibility",
        "annotations"
      ])
    };
  }
  contributeToSchemaILFBase() {
  }
  setProp(prop) {
    this.options = {
      ...this.options,
      ...prop
    };
    return this;
  }
};
function makeField(fieldFactory) {
  const fieldMaker = (options) => {
    const label = typeof options === "string" ? options : void 0;
    const passedOptions = (typeof options !== "string" ? options : options) ?? {};
    const passedStageVisibility = passedOptions == null ? void 0 : passedOptions.stageVisibility;
    const stageVisibility = {
      ...GenericDefaults.stageVisibility,
      ...passedStageVisibility
    };
    const passedAnnotations = passedOptions == null ? void 0 : passedOptions.annotations;
    const annotations = {
      ...GenericDefaults.annotations,
      ...passedAnnotations
    };
    const fullOpts = {
      ...GenericDefaults,
      ...FieldHookDefaults(),
      ...label ? { label } : { ...passedOptions },
      stageVisibility,
      annotations
    };
    const field = new Field(fullOpts);
    const fieldOptions = fieldFactory(field, passedOptions);
    field.addCustomOptionsToField(fieldOptions);
    return field;
  };
  return fieldMaker;
}
var TextField = makeField((field, passedOptions) => {
  return () => {
    const cast = passedOptions.cast ?? StringCast;
    return field.setProp({ type: "string", cast });
  };
});
var BooleanField = makeField((field, passedOptions) => {
  return () => {
    const cast = passedOptions.cast ?? BooleanCast;
    return field.setProp({ type: "boolean", cast });
  };
});
var NumberField = makeField((field, passedOptions) => {
  return () => {
    const cast = passedOptions.cast ?? NumberCast;
    return field.setProp({ type: "number", cast });
  };
});
var DateField = makeField((field, passedOptions) => {
  return () => {
    const cast = passedOptions.cast ?? DateCast;
    return field.setProp({ type: "string", cast });
  };
});
var OptionField = makeField((field) => {
  const def_ = field.options.default;
  if (def_ !== null) {
    if (isFullyPresent(def_) && field.options.options[def_] === void 0) {
      throw new Error(`Invalid default of ${def_}, value doesn't appear as one of the keys in ${(0, import_remeda.keys)(field.options.options)}`);
    }
  }
  const labelEnum = (0, import_remeda.mapValues)(field.options.options, (value) => {
    const label = typeof value === "string" ? value : value.label;
    return label;
  });
  return () => field.setProp({ type: "enum", labelEnum });
});
var LinkedField = makeField((field) => {
  const { sheet } = field.options;
  const sheetName = sheet.name;
  return () => field.setProp({ type: "schema_ref", sheetName });
});

// src/ddl/Portal.ts
var Portal = class {
  constructor(options) {
    this.options = options;
  }
  setId(id) {
    this.id = id;
  }
  setPrivateKeyString(privateKeyString) {
    this.privateKeyString = privateKeyString;
  }
};

// src/ddl/Sheet.ts
var import_schema = require("@flatfile/schema");
var import_remeda2 = require("remeda");
var UniqueAndRequiredPlugin = class {
  run(fields, records) {
    const uniques = {};
    const requiredFields = [];
    for (let x in fields) {
      if (fields[x].options.unique === true) {
        uniques[x] = {};
      }
      if (fields[x].options.required === true) {
        requiredFields.push(x);
      }
    }
    records.map((record, index) => {
      requiredFields.forEach((field) => {
        const value = record.get(field);
        if (!isFullyPresent(value)) {
          record.addError(field, "Required Value");
        }
      });
      for (let uniqueFieldKey in uniques) {
        const origValue = record.get(uniqueFieldKey);
        const value = typeof origValue === "boolean" ? String(origValue) : origValue;
        if (value === null) {
          continue;
        }
        const uniqueObj = uniques[uniqueFieldKey];
        if (isFullyPresent(uniqueObj[value])) {
          uniqueObj[value].push(index);
        } else {
          if (isFullyPresent(value)) {
            uniqueObj[value] = [index];
          }
        }
      }
    });
    for (let uniqueFieldKey in uniques) {
      for (let value in uniques[uniqueFieldKey]) {
        if (uniques[uniqueFieldKey][value].length > 1) {
          const indexes = uniques[uniqueFieldKey][value];
          indexes.forEach((index) => {
            records[index].addError(uniqueFieldKey, "Value must be unique");
          });
        }
      }
    }
  }
};
var Sheet = class {
  constructor(name, fields, passedOptions) {
    this.name = name;
    this.fields = fields;
    this.passedOptions = passedOptions;
    this.options = {
      allowCustomFields: false,
      readOnly: false,
      recordCompute() {
      },
      batchRecordsCompute: async (records) => {
      }
    };
    this.contributedRecordFuncs = {};
    if (passedOptions) {
      Object.assign(this.options, passedOptions);
    }
    const malleableFields = fields;
    (0, import_remeda2.toPairs)(fields).map(([key, field]) => {
      if (field.options.contributeToRecordCompute) {
        this.contributedRecordFuncs[key] = field.options.contributeToRecordCompute;
      }
      (0, import_remeda2.toPairs)(field.extraFieldsToAdd).map(([extraKey, extraField]) => {
        if (fields[extraKey] === void 0) {
          malleableFields[extraKey] = extraField;
        } else {
          throw Error(`extraFieldsToAdd error, ${extraKey} already exists in fields, ${key} was trying to add it`);
        }
      });
    });
    this.fields = malleableFields;
  }
  async runProcess(records, session, logger) {
    records.records.map((record) => {
      (0, import_remeda2.toPairs)(this.fields).map(([key, field]) => {
        const origVal = record.get(key);
        const [newVal, messages] = field.computeToValue(origVal);
        if (newVal !== void 0) {
          record.set(key, newVal);
        }
        messages.map((m) => record.pushInfoMessage(key, m.message, m.level, m.stage));
        return record;
      });
    });
    records.records.map(async (record) => {
      (0, import_remeda2.toPairs)(this.contributedRecordFuncs).map(([fieldName, recordCompute]) => {
        try {
          recordCompute(record, session, logger);
        } catch (e) {
          console.log(`error with contributedRecordCompute for ${fieldName}`, e);
        }
      });
      this.options.recordCompute(record, session, logger);
    });
    await this.options.batchRecordsCompute(records, session, logger);
    records.records.map(async (record) => {
      (0, import_remeda2.toPairs)(this.fields).map(async ([key, field]) => {
        const origVal = record.get(key);
        if (isFullyPresent(origVal)) {
          const messages = field.validate(origVal);
          if (messages) {
            messages.map((m) => {
              record.pushInfoMessage(key, m.message, m.level, m.stage);
            });
          }
        }
      });
    });
    if (!logger) {
      const testPlugin = new UniqueAndRequiredPlugin();
      testPlugin.run(this.fields, records.records);
    }
  }
  toSchemaIL(namespace, slug) {
    let base = {
      name: this.name,
      slug,
      namespace,
      fields: {},
      allowCustomFields: this.options.allowCustomFields
    };
    for (const key in this.fields) {
      base.fields[key] = this.fields[key].toSchemaILField(key);
    }
    return base;
  }
  toJSONSchema(namespace, slug) {
    return (0, import_schema.SchemaILToJsonSchema)(this.toSchemaIL(namespace, slug));
  }
};

// ../hooks/dist/index.mjs
var FlatfileRecord = class {
  constructor(raw) {
    this._info = [];
    this.mutated = Object.assign({}, raw.rawData);
    this.data = Object.assign({}, raw.rawData);
    this._rowId = raw.rowId;
  }
  get rowId() {
    return this._rowId;
  }
  get originalValue() {
    return this.data;
  }
  get value() {
    return this.mutated;
  }
  verifyField(field) {
    if (!Object.prototype.hasOwnProperty.call(this.data, field)) {
      console.error(`Record does not have field "${field}".`);
      return false;
    }
    return true;
  }
  set(field, value) {
    if (!this.verifyField(field)) {
      return this;
    }
    Object.defineProperty(this.mutated, field, {
      value
    });
    return this;
  }
  get(field) {
    if (this.verifyField(field)) {
      return this.mutated[field];
    }
    return null;
  }
  addInfo(fields, message) {
    return this.pushInfoMessage(fields, message, "info", "other");
  }
  addComment(fields, message) {
    return this.addInfo(fields, message);
  }
  addError(fields, message) {
    return this.pushInfoMessage(fields, message, "error", "other");
  }
  addWarning(fields, message) {
    return this.pushInfoMessage(fields, message, "warn", "other");
  }
  pushInfoMessage(fields, message, level, stage) {
    fields = Array.isArray(fields) ? fields : [fields];
    fields.forEach((field) => {
      if (this.verifyField(field)) {
        this._info.push({
          field,
          message,
          level,
          stage
        });
      }
    });
    return this;
  }
  toJSON() {
    return {
      row: {
        rawData: this.mutated,
        rowId: this.rowId
      },
      info: this._info
    };
  }
};
var FlatfileRecords = class {
  constructor(rawRecords) {
    this._records = rawRecords.map((rawRecord) => new FlatfileRecord(rawRecord));
  }
  get records() {
    return this._records;
  }
  toJSON() {
    return this.records.map((record) => record.toJSON());
  }
};

// src/ddl/Workbook.ts
var Workbook = class {
  constructor(options) {
    this.options = options;
    this.runHookOnLambda = async ({
      recordBatch,
      session,
      logger,
      eventType = "records/change"
    }) => {
      await this.processRecords(recordBatch, session, logger);
      return recordBatch.toJSON();
    };
  }
  async processRecords(records, payload, logger) {
    const { namespace } = this.options;
    const sheetTarget = payload.schemaSlug;
    const targets = Object.keys(this.options.sheets);
    const foundTarget = targets.find((t) => sheetTarget.includes(namespace + "/" + t));
    if (foundTarget) {
      await this.options.sheets[foundTarget].runProcess(records, payload, logger);
    } else {
      throw new Error("no target found");
    }
  }
  async handleLegacyDataHook(payload) {
    const recordBatch = new FlatfileRecords(payload.rows.map((r) => r.row));
    await this.processRecords(recordBatch, payload);
    return recordBatch.toJSON();
  }
};

// src/stdlib/constants/country_codes.ts
var COUNTRY_CODES = [
  ["Afghanistan", "AF", "AFG"],
  ["\xC5land Islands", "AX", "ALA"],
  ["Albania", "AL", "ALB"],
  ["Algeria", "DZ", "DZA"],
  ["American Samoa", "AS", "ASM"],
  ["Andorra", "AD", "AND"],
  ["Angola", "AO", "AGO"],
  ["Anguilla", "AI", "AIA"],
  ["Antarctica", "AQ", "ATA"],
  ["Antigua and Barbuda", "AG", "ATG"],
  ["Argentina", "AR", "ARG"],
  ["Armenia", "AM", "ARM"],
  ["Aruba", "AW", "ABW"],
  ["Australia", "AU", "AUS"],
  ["Austria", "AT", "AUT"],
  ["Azerbaijan", "AZ", "AZE"],
  ["Bahamas", "BS", "BHS"],
  ["Bahrain", "BH", "BHR"],
  ["Bangladesh", "BD", "BGD"],
  ["Barbados", "BB", "BRB"],
  ["Belarus", "BY", "BLR"],
  ["Belgium", "BE", "BEL"],
  ["Belize", "BZ", "BLZ"],
  ["Benin", "BJ", "BEN"],
  ["Bermuda", "BM", "BMU"],
  ["Bhutan", "BT", "BTN"],
  ["Bolivia", "BO", "BOL"],
  ["Bonaire, Sint Eustatius and Saba", "BQ", "BES"],
  ["Bosnia and Herzegovina", "BA", "BIH"],
  ["Botswana", "BW", "BWA"],
  ["Bouvet Island", "BV", "BVT"],
  ["Brazil", "BR", "BRA"],
  ["British Indian Ocean Territory", "IO", "IOT"],
  ["Brunei Darussalam", "BN", "BRN"],
  ["Bulgaria", "BG", "BGR"],
  ["Burkina Faso", "BF", "BFA"],
  ["Burundi", "BI", "BDI"],
  ["Cabo Verde", "CV", "CPV"],
  ["Cambodia", "KH", "KHM"],
  ["Cameroon", "CM", "CMR"],
  ["Canada", "CA", "CAN"],
  ["Cayman Islands", "KY", "CYM"],
  ["Central African Republic", "CF", "CAF"],
  ["Chad", "TD", "TCD"],
  ["Chile", "CL", "CHL"],
  ["China", "CN", "CHN"],
  ["Christmas Island", "CX", "CXR"],
  ["Cocos (Keeling) Islands", "CC", "CCK"],
  ["Colombia", "CO", "COL"],
  ["Comoros", "KM", "COM"],
  ["Congo", "CG", "COG"],
  ["Congo, Democratic Republic of the", "CD", "COD"],
  ["Cook Islands", "CK", "COK"],
  ["Costa Rica", "CR", "CRI"],
  ["C\xF4te d'Ivoire", "CI", "CIV"],
  ["Croatia", "HR", "HRV"],
  ["Cuba", "CU", "CUB"],
  ["Cura\xE7ao", "CW", "CUW"],
  ["Cyprus", "CY", "CYP"],
  ["Czechia", "CZ", "CZE"],
  ["Denmark", "DK", "DNK"],
  ["Djibouti", "DJ", "DJI"],
  ["Dominica", "DM", "DMA"],
  ["Dominican Republic", "DO", "DOM"],
  ["Ecuador", "EC", "ECU"],
  ["Egypt", "EG", "EGY"],
  ["El Salvador", "SV", "SLV"],
  ["Equatorial Guinea", "GQ", "GNQ"],
  ["Eritrea", "ER", "ERI"],
  ["Estonia", "EE", "EST"],
  ["Eswatini", "SZ", "SWZ"],
  ["Ethiopia", "ET", "ETH"],
  ["Falkland Islands (Malvinas)[b]", "FK", "FLK"],
  ["Faroe Islands", "FO", "FRO"],
  ["Fiji", "FJ", "FJI"],
  ["Finland", "FI", "FIN"],
  ["France", "FR", "FRA"],
  ["French Guiana", "GF", "GUF"],
  ["French Polynesia", "PF", "PYF"],
  ["French Southern Territories", "TF", "ATF"],
  ["Gabon", "GA", "GAB"],
  ["Gambia", "GM", "GMB"],
  ["Georgia", "GE", "GEO"],
  ["Germany", "DE", "DEU"],
  ["Ghana", "GH", "GHA"],
  ["Gibraltar", "GI", "GIB"],
  ["Greece", "GR", "GRC"],
  ["Greenland", "GL", "GRL"],
  ["Grenada", "GD", "GRD"],
  ["Guadeloupe", "GP", "GLP"],
  ["Guam", "GU", "GUM"],
  ["Guatemala", "GT", "GTM"],
  ["Guernsey", "GG", "GGY"],
  ["Guinea", "GN", "GIN"],
  ["Guinea-Bissau", "GW", "GNB"],
  ["Guyana", "GY", "GUY"],
  ["Haiti", "HT", "HTI"],
  ["Heard Island and McDonald Islands", "HM", "HMD"],
  ["Holy See", "VA", "VAT"],
  ["Honduras", "HN", "HND"],
  ["Hong Kong", "HK", "HKG"],
  ["Hungary", "HU", "HUN"],
  ["Iceland", "IS", "ISL"],
  ["India", "IN", "IND"],
  ["Indonesia", "ID", "IDN"],
  ["Iran (Islamic Republic of)", "IR", "IRN"],
  ["Iraq", "IQ", "IRQ"],
  ["Ireland", "IE", "IRL"],
  ["Isle of Man", "IM", "IMN"],
  ["Israel", "IL", "ISR"],
  ["Italy", "IT", "ITA"],
  ["Jamaica", "JM", "JAM"],
  ["Japan", "JP", "JPN"],
  ["Jersey", "JE", "JEY"],
  ["Jordan", "JO", "JOR"],
  ["Kazakhstan", "KZ", "KAZ"],
  ["Kenya", "KE", "KEN"],
  ["Kiribati", "KI", "KIR"],
  ["Korea (Democratic People's Republic of)", "KP", "PRK"],
  ["Korea, Republic of", "KR", "KOR"],
  ["Kuwait", "KW", "KWT"],
  ["Kyrgyzstan", "KG", "KGZ"],
  ["Lao People's Democratic Republic", "LA", "LAO"],
  ["Latvia", "LV", "LVA"],
  ["Lebanon", "LB", "LBN"],
  ["Lesotho", "LS", "LSO"],
  ["Liberia", "LR", "LBR"],
  ["Libya", "LY", "LBY"],
  ["Liechtenstein", "LI", "LIE"],
  ["Lithuania", "LT", "LTU"],
  ["Luxembourg", "LU", "LUX"],
  ["Macao", "MO", "MAC"],
  ["Madagascar", "MG", "MDG"],
  ["Malawi", "MW", "MWI"],
  ["Malaysia", "MY", "MYS"],
  ["Maldives", "MV", "MDV"],
  ["Mali", "ML", "MLI"],
  ["Malta", "MT", "MLT"],
  ["Marshall Islands", "MH", "MHL"],
  ["Martinique", "MQ", "MTQ"],
  ["Mauritania", "MR", "MRT"],
  ["Mauritius", "MU", "MUS"],
  ["Mayotte", "YT", "MYT"],
  ["Mexico", "MX", "MEX"],
  ["Micronesia (Federated States of)", "FM", "FSM"],
  ["Moldova, Republic of", "MD", "MDA"],
  ["Monaco", "MC", "MCO"],
  ["Mongolia", "MN", "MNG"],
  ["Montenegro", "ME", "MNE"],
  ["Montserrat", "MS", "MSR"],
  ["Morocco", "MA", "MAR"],
  ["Mozambique", "MZ", "MOZ"],
  ["Myanmar", "MM", "MMR"],
  ["Namibia", "NA", "NAM"],
  ["Nauru", "NR", "NRU"],
  ["Nepal", "NP", "NPL"],
  ["Netherlands", "NL", "NLD"],
  ["New Caledonia", "NC", "NCL"],
  ["New Zealand", "NZ", "NZL"],
  ["Nicaragua", "NI", "NIC"],
  ["Niger", "NE", "NER"],
  ["Nigeria", "NG", "NGA"],
  ["Niue", "NU", "NIU"],
  ["Norfolk Island", "NF", "NFK"],
  ["North Macedonia", "MK", "MKD"],
  ["Northern Mariana Islands", "MP", "MNP"],
  ["Norway", "NO", "NOR"],
  ["Oman", "OM", "OMN"],
  ["Pakistan", "PK", "PAK"],
  ["Palau", "PW", "PLW"],
  ["Palestine, State of[b]", "PS", "PSE"],
  ["Panama", "PA", "PAN"],
  ["Papua New Guinea", "PG", "PNG"],
  ["Paraguay", "PY", "PRY"],
  ["Peru", "PE", "PER"],
  ["Philippines", "PH", "PHL"],
  ["Pitcairn", "PN", "PCN"],
  ["Poland", "PL", "POL"],
  ["Portugal", "PT", "PRT"],
  ["Puerto Rico", "PR", "PRI"],
  ["Qatar", "QA", "QAT"],
  ["R\xE9union", "RE", "REU"],
  ["Romania", "RO", "ROU"],
  ["Russian Federation", "RU", "RUS"],
  ["Rwanda", "RW", "RWA"],
  ["Saint Barth\xE9lemy", "BL", "BLM"],
  ["Saint Helena, Ascension and Tristan da Cunha", "SH", "SHN"],
  ["Saint Kitts and Nevis", "KN", "KNA"],
  ["Saint Lucia", "LC", "LCA"],
  ["Saint Martin (French part)", "MF", "MAF"],
  ["Saint Pierre and Miquelon", "PM", "SPM"],
  ["Saint Vincent and the Grenadines", "VC", "VCT"],
  ["Samoa", "WS", "WSM"],
  ["San Marino", "SM", "SMR"],
  ["Sao Tome and Principe", "ST", "STP"],
  ["Saudi Arabia", "SA", "SAU"],
  ["Senegal", "SN", "SEN"],
  ["Serbia", "RS", "SRB"],
  ["Seychelles", "SC", "SYC"],
  ["Sierra Leone", "SL", "SLE"],
  ["Singapore", "SG", "SGP"],
  ["Sint Maarten (Dutch part)", "SX", "SXM"],
  ["Slovakia", "SK", "SVK"],
  ["Slovenia", "SI", "SVN"],
  ["Solomon Islands", "SB", "SLB"],
  ["Somalia", "SO", "SOM"],
  ["South Africa", "ZA", "ZAF"],
  ["South Georgia and the South Sandwich Islands", "GS", "SGS"],
  ["South Sudan", "SS", "SSD"],
  ["Spain", "ES", "ESP"],
  ["Sri Lanka", "LK", "LKA"],
  ["Sudan", "SD", "SDN"],
  ["Suriname", "SR", "SUR"],
  ["Svalbard and Jan Mayen[e]", "SJ", "SJM"],
  ["Sweden", "SE", "SWE"],
  ["Switzerland", "CH", "CHE"],
  ["Syrian Arab Republic", "SY", "SYR"],
  ["Taiwan", "TW", "TWN"],
  ["Tajikistan", "TJ", "TJK"],
  ["Tanzania, United Republic of", "TZ", "TZA"],
  ["Thailand", "TH", "THA"],
  ["Timor-Leste", "TL", "TLS"],
  ["Togo", "TG", "TGO"],
  ["Tokelau", "TK", "TKL"],
  ["Tonga", "TO", "TON"],
  ["Trinidad and Tobago", "TT", "TTO"],
  ["Tunisia", "TN", "TUN"],
  ["T\xFCrkiye", "TR", "TUR"],
  ["Turkmenistan", "TM", "TKM"],
  ["Turks and Caicos Islands", "TC", "TCA"],
  ["Tuvalu", "TV", "TUV"],
  ["Uganda", "UG", "UGA"],
  ["Ukraine", "UA", "UKR"],
  ["United Arab Emirates", "AE", "ARE"],
  ["United Kingdom of Great Britain and Northern Ireland", "GB", "GBR"],
  ["United States of America", "US", "USA"],
  ["United States Minor Outlying Islands", "UM", "UMI"],
  ["Uruguay", "UY", "URY"],
  ["Uzbekistan", "UZ", "UZB"],
  ["Vanuatu", "VU", "VUT"],
  ["Venezuela (Bolivarian Republic of)", "VE", "VEN"],
  ["Viet Nam", "VN", "VNM"],
  ["Virgin Islands (British)", "VG", "VGB"],
  ["Virgin Islands (U.S.)", "VI", "VIR"],
  ["Wallis and Futuna", "WF", "WLF"],
  ["Western Sahara[b]", "EH", "ESH"],
  ["Yemen", "YE", "YEM"],
  ["Zambia", "ZM", "ZMB"],
  ["Zimbabwe", "ZW", "ZWE"]
];

// src/stdlib/constants/us_states.ts
var US_STATES = [
  ["Alabama", "AL"],
  ["Alaska", "AK"],
  ["Arizona", "AZ"],
  ["Arkansas", "AR"],
  ["California", "CA"],
  ["Colorado", "CO"],
  ["Connecticut", "CT"],
  ["Delaware", "DE"],
  ["District of Columbia", "DC"],
  ["Florida", "FL"],
  ["Georgia", "GA"],
  ["Hawaii", "HI"],
  ["Idaho", "ID"],
  ["Illinois", "IL"],
  ["Indiana", "IN"],
  ["Iowa", "IA"],
  ["Kansas", "KS"],
  ["Kentucky", "KY"],
  ["Louisiana", "LA"],
  ["Maine", "ME"],
  ["Maryland", "MD"],
  ["Massachusetts", "MA"],
  ["Michigan", "MI"],
  ["Minnesota", "MN"],
  ["Mississippi", "MS"],
  ["Missouri", "MO"],
  ["Montana", "MT"],
  ["Nebraska", "NE"],
  ["Nevada", "NV"],
  ["New Hampshire", "NH"],
  ["New Jersey", "NJ"],
  ["New Mexico", "NM"],
  ["New York", "NY"],
  ["North Carolina", "NC"],
  ["North Dakota", "ND"],
  ["Ohio", "OH"],
  ["Oklahoma", "OK"],
  ["Oregon", "OR"],
  ["Pennsylvania", "PA"],
  ["Rhode Island", "RI"],
  ["South Carolina", "SC"],
  ["South Dakota", "SD"],
  ["Tennessee", "TN"],
  ["Texas", "TX"],
  ["Utah", "UT"],
  ["Vermont", "VT"],
  ["Virginia", "VA"],
  ["Washington", "WA"],
  ["West Virginia", "WV"],
  ["Wisconsin", "WI"],
  ["Wyoming", "WY"]
];
var US_TERRITORIES = [
  ["American Samoa", "AS"],
  ["Guam", "GU"],
  ["Northern Mariana Islands", "MP"],
  ["Puerto Rico", "PR"],
  ["Virgin Islands", "VI"]
];
var US_STATES_AND_TERRITORIES = US_STATES.concat(US_TERRITORIES);

// src/stdlib/SubstitutionCast.ts
var import_remeda3 = require("remeda");
var SubstitutionCast = (matchingLists, outputColNum, errorFunc) => {
  const retFunc = StringCastCompose((val) => {
    const candidates = (0, import_remeda3.filter)(matchingLists, (row) => row.includes(val));
    if (candidates.length == 0) {
      throw new Error(errorFunc(val));
    }
    if (candidates.length == 1) {
      return candidates[0][outputColNum];
    }
  });
  return retFunc;
};
var StringSubstitutionCast = (matchingLists, outputColNum, errorFunc) => {
  const retFunc = StringCastCompose((val) => {
    const candidates = (0, import_remeda3.filter)(matchingLists, (row) => (0, import_remeda3.map)(row, (x) => x.toLowerCase()).includes(val.toLowerCase()));
    if (candidates.length == 0) {
      throw new Error(errorFunc(val));
    }
    if (candidates.length == 1) {
      return candidates[0][outputColNum];
    }
  });
  return retFunc;
};

// src/stdlib/RegionCast.ts
var CountryCast = (toFormat) => {
  const colNums = { full: 0, "iso-2": 1, "iso-3": 2 };
  return StringSubstitutionCast(COUNTRY_CODES, colNums[toFormat], (val) => `Couldn't convert '${val}' to a country`);
};
var StateCast = (toFormat) => {
  const colNums = { full: 0, "two-letter": 1 };
  return StringSubstitutionCast(US_STATES, colNums[toFormat], (val) => `Couldn't convert '${val}' to a state`);
};
var StateAndTerritoryCast = (toFormat) => {
  const colNums = { full: 0, "two-letter": 1 };
  return StringSubstitutionCast(US_STATES_AND_TERRITORIES, colNums[toFormat], (val) => `Couldn't convert '${val}' to a state`);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BooleanField,
  CountryCast,
  DateField,
  Field,
  FieldHookDefaults,
  LinkedField,
  Message,
  NumberField,
  OptionField,
  Portal,
  Sheet,
  StateAndTerritoryCast,
  StateCast,
  StringSubstitutionCast,
  SubstitutionCast,
  TextField,
  UniqueAndRequiredPlugin,
  Workbook
});
